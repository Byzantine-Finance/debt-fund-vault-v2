// SPDX-License-Identifier: GPL-2.0-or-later
// Copyright (c) 2025 [Byzantine Finance]
// The implementation of this contract was inspired by Morpho Vault V2, developed by the Morpho Association in 2025.
pragma solidity ^0.8.0;

import {stdJson} from "../../lib/forge-std/src/StdJson.sol";
import "./ERC4626MerklAdapterIntegrationTest.sol";

/// @dev This test uses claim data generated by the claimer bot on base fork
contract ERC4626MerklAdapterIntegrationClaimTest is ERC4626MerklAdapterIntegrationTest {
    // Base contracts and fork block
    IERC20 constant baseUSDC = IERC20(0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913);
    IERC4626 constant baseStataUSDC = IERC4626(0xC768c589647798a6EE01A91FdE98EF2ed046DBD6);

    // Claiming data (bot generated)
    uint256 internal baseForkBlock;
    address internal vaultAddr;
    address internal adapterAddr;
    address internal rewardToken;
    uint256 internal rewardAmount;
    address internal lifiDiamond;
    uint256 internal usdcMinAmountReceived;
    bytes internal swapData;
    bytes internal claimData;

    // Load claim data from JSON file
    string internal root = vm.projectRoot();
    string internal path = string.concat(root, "/test/data/claim_data_merkl_base.json");

    function setUp() public virtual override {
        _loadClaimData(path);

        // Create base fork
        rpcUrl = vm.envString("BASE_RPC_URL");
        forkId = vm.createFork(rpcUrl, baseForkBlock);
        vm.selectFork(forkId);
        skipMainnetFork = true;

        // Set base contracts
        usdc = baseUSDC;
        stataUSDC = baseStataUSDC;

        super.setUp();

        // Deploy an apdater with parent vault being `vaultAddr` and etch code to `adapterAddr`
        erc4626MerklAdapter =
            IERC4626MerklAdapter(erc4626MerklAdapterFactory.createERC4626MerklAdapter(vaultAddr, address(stataUSDC)));
        vm.etch(adapterAddr, address(erc4626MerklAdapter).code);

        // Set claimer role in etched adapter
        vm.prank(IVaultV2(vaultAddr).curator());
        IERC4626MerklAdapter(adapterAddr).setClaimer(rewardClaimer);
    }

    function testClaim() public {
        uint256 vaultAssetBalanceBefore = IERC20(IVaultV2(vaultAddr).asset()).balanceOf(vaultAddr);

        vm.expectEmit();
        emit IERC4626MerklAdapter.ClaimRewards(rewardToken, rewardAmount);

        vm.expectEmit();
        emit IERC4626MerklAdapter.SwapRewards(lifiDiamond, rewardToken, rewardAmount, swapData);

        // Claim and swap Merkl rewards
        vm.prank(rewardClaimer);
        IERC4626MerklAdapter(adapterAddr).claim(claimData);

        uint256 vaultAssetBalanceAfter = IERC20(IVaultV2(vaultAddr).asset()).balanceOf(vaultAddr);
        uint256 rewardsInUSDC = vaultAssetBalanceAfter - vaultAssetBalanceBefore;

        assertGe(rewardsInUSDC, usdcMinAmountReceived);
    }

    function _loadClaimData(string memory _path) internal {
        string memory json = vm.readFile(_path);

        baseForkBlock = stdJson.readUint(json, ".blockNumber");
        vaultAddr = stdJson.readAddress(json, ".vaultAddr");
        adapterAddr = stdJson.readAddress(json, ".adapterAddr");
        rewardToken = stdJson.readAddress(json, ".rewardToken");
        rewardAmount = stdJson.readUint(json, ".rewardAmount");
        lifiDiamond = stdJson.readAddress(json, ".lifiDiamond");
        usdcMinAmountReceived = stdJson.readUint(json, ".toAmountMin");
        swapData = stdJson.readBytes(json, ".swapCalldata");
        claimData = stdJson.readBytes(json, ".claimCalldata");

        vm.label(adapterAddr, "baseRealAdapter");
        vm.label(rewardToken, "rewardToken");
    }
}
