// SPDX-License-Identifier: GPL-2.0-or-later
// Copyright (c) 2025 [Byzantine Finance]
// The implementation of this contract was inspired by Morpho Vault V2, developed by the Morpho Association in 2025.
pragma solidity ^0.8.0;

import {stdJson} from "../../lib/forge-std/src/StdJson.sol";
import "./ERC4626MerklAdapterIntegrationTest.sol";
import {ERC4626MerklAdapter} from "../../src/adapters/ERC4626MerklAdapter.sol";

/// @dev This test uses claim data generated by the claimer bot on base fork
contract ERC4626MerklAdapterIntegrationClaimTest is ERC4626MerklAdapterIntegrationTest {
    // Base contracts and fork block
    IERC20 constant baseUSDC = IERC20(0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913);
    IERC4626 constant baseStataUSDC = IERC4626(0xC768c589647798a6EE01A91FdE98EF2ed046DBD6);

    // Claiming data (bot generated)
    uint256 internal baseForkBlock;
    address internal vaultAddr;
    address internal adapterAddr;
    address internal rewardToken;
    uint256 internal rewardAmount;
    address internal lifiDiamond;
    uint256 internal usdcMinAmountReceived;
    bytes internal swapData;
    bytes internal claimData;

    // Load claim data from JSON file
    string internal root = vm.projectRoot();
    string internal path = string.concat(root, "/test/data/claim_data_merkl_base.json");

    function setUp() public virtual override {
        _loadClaimData(path);

        // Create base fork
        rpcUrl = vm.envString("BASE_RPC_URL");
        forkId = vm.createFork(rpcUrl, baseForkBlock);
        vm.selectFork(forkId);
        skipMainnetFork = true;

        // Set base contracts
        usdc = baseUSDC;
        stataUSDC = baseStataUSDC;

        super.setUp();

        // Deploy an apdater with parent vault being `vaultAddr` and etch code to `adapterAddr`
        erc4626MerklAdapter =
            IERC4626MerklAdapter(erc4626MerklAdapterFactory.createERC4626MerklAdapter(vaultAddr, address(stataUSDC)));
        vm.etch(adapterAddr, address(erc4626MerklAdapter).code);

        // Set claimer role in etched adapter
        vm.prank(IVaultV2(vaultAddr).curator());
        IERC4626MerklAdapter(adapterAddr).setClaimer(rewardClaimer);
    }

    function testClaim() public {
        uint256 vaultAssetBalanceBefore = IERC20(IVaultV2(vaultAddr).asset()).balanceOf(vaultAddr);

        vm.expectEmit();
        emit IERC4626MerklAdapter.ClaimRewards(rewardToken, rewardAmount);

        vm.expectEmit();
        emit IERC4626MerklAdapter.SwapRewards(lifiDiamond, rewardToken, rewardAmount, swapData);

        // Claim and swap Merkl rewards
        vm.prank(rewardClaimer);
        IERC4626MerklAdapter(adapterAddr).claim(claimData);

        uint256 vaultAssetBalanceAfter = IERC20(IVaultV2(vaultAddr).asset()).balanceOf(vaultAddr);
        uint256 rewardsInUSDC = vaultAssetBalanceAfter - vaultAssetBalanceBefore;

        assertGe(rewardsInUSDC, usdcMinAmountReceived);
    }

    function testSetClaimerNotAuthorizedReverts(address newClaimer) public {
        vm.expectRevert(IERC4626MerklAdapter.NotAuthorized.selector);
        IERC4626MerklAdapter(adapterAddr).setClaimer(newClaimer);
    }

    function testClaimNotAuthorizedReverts(bytes memory data) public {
        vm.expectRevert(IERC4626MerklAdapter.NotAuthorized.selector);
        IERC4626MerklAdapter(adapterAddr).claim(data);
    }

    function testClaimSwapperCannotBeTiedContractReverts() public {
        (IERC4626MerklAdapter.MerklParams memory merklParams, IERC4626MerklAdapter.SwapParams[] memory swapParams) =
            abi.decode(claimData, (IERC4626MerklAdapter.MerklParams, IERC4626MerklAdapter.SwapParams[]));

        // create a new swap params with incorrect address as swapper
        IERC4626MerklAdapter.SwapParams[] memory newSwapParams =
            new IERC4626MerklAdapter.SwapParams[](swapParams.length);
        for (uint256 i = 0; i < swapParams.length; i++) {
            newSwapParams[i] = swapParams[i];
        }

        newSwapParams[0].swapper = address(baseStataUSDC);

        vm.expectRevert(IERC4626MerklAdapter.SwapperCannotBeTiedContract.selector);
        vm.prank(rewardClaimer);
        IERC4626MerklAdapter(adapterAddr).claim(abi.encode(merklParams, newSwapParams));

        newSwapParams[0].swapper = address(vaultAddr);

        vm.expectRevert(IERC4626MerklAdapter.SwapperCannotBeTiedContract.selector);
        vm.prank(rewardClaimer);
        IERC4626MerklAdapter(adapterAddr).claim(abi.encode(merklParams, newSwapParams));

        newSwapParams[0].swapper = ERC4626MerklAdapter(adapterAddr).MERKL_DISTRIBUTOR();

        vm.expectRevert(IERC4626MerklAdapter.SwapperCannotBeTiedContract.selector);
        vm.prank(rewardClaimer);
        IERC4626MerklAdapter(adapterAddr).claim(abi.encode(merklParams, newSwapParams));
    }

    function testClaimSwapRevertedReverts() public {
        (IERC4626MerklAdapter.MerklParams memory merklParams, IERC4626MerklAdapter.SwapParams[] memory swapParams) =
            abi.decode(claimData, (IERC4626MerklAdapter.MerklParams, IERC4626MerklAdapter.SwapParams[]));

        // create a new swap params with incorrect swap data
        IERC4626MerklAdapter.SwapParams[] memory newSwapParams =
            new IERC4626MerklAdapter.SwapParams[](swapParams.length);
        for (uint256 i = 0; i < swapParams.length; i++) {
            newSwapParams[i] = swapParams[i];
        }
        newSwapParams[0].swapData = hex"1111";

        vm.expectRevert(IERC4626MerklAdapter.SwapReverted.selector);
        vm.prank(rewardClaimer);
        IERC4626MerklAdapter(adapterAddr).claim(abi.encode(merklParams, newSwapParams));
    }

    function testClaimInvalidDataReverts() public {
        (IERC4626MerklAdapter.MerklParams memory merklParams, IERC4626MerklAdapter.SwapParams[] memory swapParams) =
            abi.decode(claimData, (IERC4626MerklAdapter.MerklParams, IERC4626MerklAdapter.SwapParams[]));

        // Create a mismatch between swap params and token lengths
        IERC4626MerklAdapter.SwapParams[] memory newSwapParams =
            new IERC4626MerklAdapter.SwapParams[](swapParams.length - 1);
        for (uint256 i = 0; i < swapParams.length - 1; i++) {
            newSwapParams[i] = swapParams[i];
        }

        vm.expectRevert(IERC4626MerklAdapter.InvalidData.selector);
        vm.prank(rewardClaimer);
        IERC4626MerklAdapter(adapterAddr).claim(abi.encode(merklParams, newSwapParams));
    }

    function _loadClaimData(string memory _path) internal {
        string memory json = vm.readFile(_path);

        baseForkBlock = stdJson.readUint(json, ".blockNumber");
        vaultAddr = stdJson.readAddress(json, ".vaultAddr");
        adapterAddr = stdJson.readAddress(json, ".adapterAddr");
        rewardToken = stdJson.readAddress(json, ".rewardToken");
        rewardAmount = stdJson.readUint(json, ".rewardAmount");
        lifiDiamond = stdJson.readAddress(json, ".lifiDiamond");
        usdcMinAmountReceived = stdJson.readUint(json, ".toAmountMin");
        swapData = stdJson.readBytes(json, ".swapCalldata");
        claimData = stdJson.readBytes(json, ".claimCalldata");

        vm.label(adapterAddr, "baseRealAdapter");
        vm.label(rewardToken, "rewardToken");
    }
}
